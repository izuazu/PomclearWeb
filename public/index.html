<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PomClear</title>
    <link href="https://fonts.googleapis.com/css?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <script src="firebase-config.js"></script>
</head>
<body>
<div id="custom-modal-overlay" class="modal-overlay hidden">
    <div id="custom-modal-dialog" class="modal-dialog">
        <h3 id="custom-modal-title" class="modal-title">Notification</h3>
        <p id="custom-modal-message" class="modal-message">Modal message goes here.</p>
        <div class="modal-buttons">
            <button id="custom-modal-ok" class="modal-button modal-ok">OK</button>
            <button id="custom-modal-cancel" class="modal-button modal-cancel">Cancel</button>
        </div>
    </div>
</div>
<div id="auth-container" class="auth-container" style="background: url('images/PomClear.png') no-repeat center center / cover;">
    <form id="login-form" class="auth-form">
    <h2>Login</h2>
    <label for="login-email">Email:</label>
    <input type="email" id="login-email" required>
    <label for="login-password">Password:</label>
    <input type="password" id="login-password" required>
    <div class="forgot-password"><a href="#" id="forgot-password-link">Forgot Password?</a></div>
    <button type="submit">Login</button>
    <div id="login-error" class="error hidden"></div>
    <p style="text-align: center; margin-top: 10px;">Don't have an account? <a href="#" id="register-link">Register</a></p>
    </form>
    <form id="register-form" class="auth-form hidden">
    <h2>Register</h2>
    <label for="register-email">Email:</label>
    <input type="email" id="register-email" required>
    <label for="register-password">Password:</label>
    <input type="password" id="register-password" required>
    <button type="submit">Register</button>
    <div id="register-error" class="error hidden"></div>
    <p style="text-align: center; margin-top: 10px;">Already have an account? <a href="#" id="login-link">Login</a></p>
    </form>
    <form id="forgot-password-form" class="auth-form hidden">
    <h2>Reset Password</h2>
    <label for="reset-email">Email:</label>
    <input type="email" id="reset-email" required>
    <button type="submit">Send Reset Email</button>
    <div id="reset-error" class="error hidden"></div>
    <p style="text-align: center; margin-top: 10px;"><a href="#" id="back-to-login">Back to Login</a></p>
    </form>
    </div>
<div id="main-app" style="display: none;">
    <aside class="sidebar">
        <div class="sidebar-header">
            <img src="images/logo.png" alt="PomClear Logo" class="logo">
            <h2>PomClear</h2>
        </div>
        <ul class="sidebar-links">
            <li><a href="#" data-target="dashboard"><span class="material-symbols-outlined">dashboard</span><samp></samp>Dashboard</a></li>
            <li><a href="#" data-target="controlling"><span class="material-symbols-outlined">speed</span><samp></samp>Controlling</a></li>
            <li><a href="#" data-target="monitoring"><span class="material-symbols-outlined">monitoring</span><samp></samp>Monitoring</a></li>
            <li><a href="#" data-target="download"><span class="material-symbols-outlined">download</span><samp></samp>Download</a></li>
            <li><a href="#" data-target="info"><span class="material-symbols-outlined">info</span><samp></samp>Info</a></li>
            <li><a href="#" data-target="contact"><span class="material-symbols-outlined">phone</span><samp></samp>Contact</a></li>
            <li>
                <div class="account-info">
                    <a href="#" id="logout-button">
                        <span class="material-symbols-outlined">Logout</span><samp></samp>Logout
                    </a>
                </div>
            </li>
        </ul>
    </aside>
    <div class="main-content">
        <div id="dashboard" class="content active">
            <div class="dashboard-header">
                <h2>Dashboard</h2>
                <p id="account-name" class="account-name"><i class="fa-solid fa-user"></i> <span id="user-email-dashboard"></span></p>
            </div>
            <div class="dashboard-info">
                <div class="info-item">
                    <h4>pH</h4>
                    <p id="ph">Loading...</p>
                </div>
                <div class="info-item">
                    <h4>Turbidity</h4>
                    <p id="turbidity">Loading...</p>
                </div>
                <div class="info-item">
                    <h4>TDS</h4>
                    <p id="tds">Loading...</p>
                </div>
                <div class="info-item">
                    <h4>Duration</h4>
                    <p id="Durasi">Loading...</p>
                </div>
                <div class="info-item">
                    <h4>Degradation</h4>
                    <p id="degradation">Loading...</p>
                </div>
                <div class="info-item">
                    <h4>Status</h4>
                    <p id="status">Loading...</p>
                </div>
            </div>
            <div class="chart-dashboard">
                <div class="chart-controls">
                    <select id="chartSelector" onchange="updateChart(this.value)">
                        <option value="ph">pH</option>
                        <option value="turbidity">Turbidity</option>
                        <option value="tds">TDS</option>
                        <option value="degradation">Degradation</option>
                    </select>
                </div>
                <br>
                <canvas id="dashboardChart"></canvas>
            </div>
        </div>
        <div id="controlling" class="content">
            <h1>Controlling</h1>
            <fieldset>
                <legend><i class="fa-solid fa-square-check"></i> Setpoint</legend>
                <div class="setpoint-container">
                    <div class="setpoint-group">
                        <label for="minPH">Min pH</label>
                        <input type="number" id="minPH" name="minPH" placeholder="e.g. 6.5">
                    </div>
                    <div class="setpoint-group">
                        <label for="maxPH">Max pH</label>
                        <input type="number" id="maxPH" name="maxPH" placeholder="e.g. 8.5">
                    </div>
                    <div class="setpoint-group">
                        <label for="maxTDS">Max TDS</label>
                        <input type="number" id="maxTDS" name="maxTDS" placeholder="e.g. 200">
                    </div>
                    <div class="setpoint-group">
                        <label for="maxPPM">Max PPM</label>
                        <input type="number" id="maxPPM" name="maxPPM" placeholder="e.g. 100">
                    </div>
                    <div class="setpoint-group">
                        <label for="Time">Time (Minutes)</label>
                        <input type="number" id="Time" name="Time" placeholder="180">
                    </div>
                </div>
            </fieldset>
            <fieldset>
                <legend><i class="fas fa-lightbulb"></i> Control Lights</legend>
                <div class="light-grid">
                    <div class="control-item">
                        <h4>Lampu 1</h4>
                        <input type="checkbox" id="toggleButton1" class="checkbox" data-topic="iot/light1">
                        <label for="toggleButton1" class="toggle"></label>
                    </div>
                    <div class="control-item">
                        <h4>Lampu 2</h4>
                        <input type="checkbox" id="toggleButton2" class="checkbox" data-topic="iot/light2">
                        <label for="toggleButton2" class="toggle"></label>
                    </div>
                    <div class="control-item">
                        <h4>Lampu 3</h4>
                        <input type="checkbox" id="toggleButton3" class="checkbox" data-topic="iot/light3">
                        <label for="toggleButton3" class="toggle"></label>
                    </div>
                    <div class="control-item">
                        <h4>Lampu 4</h4>
                        <input type="checkbox" id="toggleButton4" class="checkbox" data-topic="iot/light4">
                        <label for="toggleButton4" class="toggle"></label>
                    </div>
                </div>
            </fieldset>
            <div class="action-buttons">
                <button type="button" id="saveButton">Save</button>
                <button type="reset" id="resetButton">Reset</button>
                <button type="button" id="startButton">Start</button>
                <button type="button" id="continueButton">Continue</button>
                <button type="button" id="stopButton">Stop</button>
            </div>
        </div>
        <script>
            const modalOverlay = document.getElementById('custom-modal-overlay');
            const modalTitle = document.getElementById('custom-modal-title');
            const modalMessage = document.getElementById('custom-modal-message');
            let modalOkButton = document.getElementById('custom-modal-ok');
            let modalCancelButton = document.getElementById('custom-modal-cancel');
            let currentConfirmResolve = null;
            function hideModal() {
                modalOverlay.classList.add('hidden');
                const okClone = modalOkButton.cloneNode(true);
                modalOkButton.parentNode.replaceChild(okClone, modalOkButton);
                modalOkButton = okClone;
                const cancelClone = modalCancelButton.cloneNode(true);
                modalCancelButton.parentNode.replaceChild(cancelClone, modalCancelButton);
                modalCancelButton = cancelClone;
                currentConfirmResolve = null;
            }
            function showModal(message, type = 'alert', title = 'Notification') {
                modalMessage.textContent = message;
                modalTitle.textContent = title;
                modalOverlay.classList.remove('hidden');
                modalOkButton.classList.add('hidden');
                modalCancelButton.classList.add('hidden');
                if (type === 'alert') {
                    modalOkButton.classList.remove('hidden');
                    modalOkButton.textContent = 'OK';
                    modalOkButton.onclick = hideModal;
                } else {
                    modalOkButton.classList.remove('hidden');
                    modalCancelButton.classList.remove('hidden');
                    modalCancelButton.textContent = 'Cancel';
                    modalOkButton.textContent = 'OK';
                    const resolve = currentConfirmResolve;
                    modalOkButton.onclick = () => {
                        hideModal();
                        if (resolve) {
                            resolve(true);
                        }
                    };
                    modalCancelButton.onclick = () => {
                        hideModal();
                        if (resolve) {
                            resolve(false);
                        }
                    };
                }
            }
            function customAlert(message, title = 'Alert') {
                showModal(message, 'alert', title);
            }
            function customConfirm(message, title = 'Confirmation') {
                if (currentConfirmResolve) {
                    currentConfirmResolve(false);
                }
                return new Promise((resolve) => {
                    currentConfirmResolve = resolve;
                    showModal(message, 'confirm', title);
                });
            }
            const auth = firebase.auth();
            const loginForm = document.getElementById('login-form');
            const registerForm = document.getElementById('register-form');
            const forgotPasswordForm = document.getElementById('forgot-password-form');
            const registerLink = document.getElementById('register-link');
            const loginLink = document.getElementById('login-link');
            const forgotPasswordLink = document.getElementById('forgot-password-link');
            const backToLoginLink = document.getElementById('back-to-login');
            const authContainer = document.getElementById('auth-container');
            const mainApp = document.getElementById('main-app');
            const logoutButton = document.getElementById('logout-button');
            const userEmailDashboard = document.getElementById('user-email-dashboard');
            function showForm(formId) {
                const forms = document.querySelectorAll('.auth-form');
                forms.forEach(form => form.classList.add('hidden'));
                document.getElementById(formId).classList.remove('hidden');
            }
            registerLink.addEventListener('click', (e) => { e.preventDefault(); showForm('register-form'); });
            loginLink.addEventListener('click', (e) => { e.preventDefault(); showForm('login-form'); });
            forgotPasswordLink.addEventListener('click', (e) => { e.preventDefault(); showForm('forgot-password-form'); });
            backToLoginLink.addEventListener('click', (e) => { e.preventDefault(); showForm('login-form'); });
            loginForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const email = document.getElementById('login-email').value;
                const password = document.getElementById('login-password').value;
                document.getElementById('login-error').classList.add('hidden');
                auth.signInWithEmailAndPassword(email, password)
                    .then((userCredential) => {})
                    .catch((error) => {
                        document.getElementById('login-error').textContent = error.message;
                        document.getElementById('login-error').classList.remove('hidden');
                    });
            });
            registerForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const email = document.getElementById('register-email').value;
                const password = document.getElementById('register-password').value;
                document.getElementById('register-error').classList.add('hidden');
                auth.createUserWithEmailAndPassword(email, password)
                    .then((userCredential) => {
                        customAlert("Registration successful! Please login.", "Success");
                        showForm('login-form');
                    })
                    .catch((error) => {
                        document.getElementById('register-error').textContent = error.message;
                        document.getElementById('register-error').classList.remove('hidden');
                    });
            });
            forgotPasswordForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const email = document.getElementById('reset-email').value;
                document.getElementById('reset-error').classList.add('hidden');
                auth.sendPasswordResetEmail(email)
                    .then(() => {
                        customAlert("Password reset email sent! Check your inbox.", "Password Reset");
                        showForm('login-form');
                    })
                    .catch((error) => {
                        document.getElementById('reset-error').textContent = error.message;
                        document.getElementById('reset-error').classList.remove('hidden');
                    });
            });
            logoutButton.addEventListener('click', () => {
                customConfirm("Are you sure you want to logout?", "Logout Confirmation")
                    .then(confirmed => {
                        if (confirmed) {
                            auth.signOut()
                                .then(() => {})
                                .catch((error) => {});
                        } else {
                        }
                    });
            });
            function showMainApp(user) {
                authContainer.style.display = 'none';
                mainApp.style.display = 'block';
                userEmailDashboard.textContent = user.email;
                activateContent('dashboard');
                localStorage.setItem('userEmail', user.email);
                loadSavedConfig();
                updateUIFromSavedConfig();
                initializeSystemState();
                const email_storage = user.email;
                sendDataToServer({ userEmail: email_storage });
                if (socket && socket.connected) {
                    socket.emit('set-email', { email_storage: email_storage });
                } else {
                }
            }
            function showLoginScreen() {
                authContainer.style.display = 'flex';
                mainApp.style.display = 'none';
                localStorage.removeItem('userEmail');
                resetSystem(true);
                showForm('login-form');
            }
            auth.onAuthStateChanged((user) => {
                if (user) {
                    showMainApp(user);
                } else {
                    showLoginScreen();
                }
            });
            const socket = io();
            let isSystemRunning = false;
            let durationInterval = null;
            let chartUpdateInterval = null;
            let dataCollectionInterval = null;
            let onlineHeartbeatTimeout = null;
            const phElement = document.getElementById('ph');
            const turbidityElement = document.getElementById('turbidity');
            const tdsElement = document.getElementById('tds');
            const DurasiElement = document.getElementById('Durasi');
            const degradationElement = document.getElementById('degradation');
            const statusElement = document.getElementById('status');
            const ctx = document.getElementById('dashboardChart').getContext('2d');
            const chartData = {
                ph: [],
                turbidity: [],
                tds: [],
                degradation: []
            };
            const chartLabels = [];
            let currentDataset = 'ph';
            let tempDataForChart = {};
            let lastPlottedValue = {};
            const dashboardChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartLabels,
                    datasets: [
                        {
                            label: 'pH Over Time',
                            data: chartData.ph,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 2,
                            tension: 0.4,
                            pointRadius: 0,
                            fill: false,
                            spanGaps: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Time' },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 0,
                                autoSkip: true,
                                maxTicksLimit: 15
                            }
                        },
                        y: {
                            title: { display: true, text: 'Value' },
                            beginAtZero: true
                        }
                    },
                    elements: {
                        line: { tension: 0.2 }
                    },
                    animation: false,
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        },
                        legend: {
                            display: false
                        }
                    }
                }
            });
            function loadChartDataFromStorage() {
                chartData.ph = JSON.parse(localStorage.getItem('chartData_ph')) || [];
                chartData.turbidity = JSON.parse(localStorage.getItem('chartData_turbidity')) || [];
                chartData.tds = JSON.parse(localStorage.getItem('chartData_tds')) || [];
                chartData.degradation = JSON.parse(localStorage.getItem('chartData_degradation')) || [];
                chartLabels.length = 0;
                const storedLabels = JSON.parse(localStorage.getItem('chartLabels')) || [];
                chartLabels.push(...storedLabels);
                lastPlottedValue = JSON.parse(localStorage.getItem('lastPlottedValue')) || {};
            }
            function updateChart(selectedDataset) {
                currentDataset = selectedDataset;
                const dataset = dashboardChart.data.datasets[0];
                if (!chartData[selectedDataset]) {
                    currentDataset = 'ph';
                }
                dataset.data = chartData[currentDataset];
                dataset.label = `${currentDataset.charAt(0).toUpperCase() + currentDataset.slice(1)} Over Time`;
                const colors = {
                    ph: { border: 'rgba(75, 192, 192, 1)', bg: 'rgba(75, 192, 192, 0.2)', point: 'rgba(75, 192, 192, 1)' },
                    turbidity: { border: 'rgba(255, 159, 64, 1)', bg: 'rgba(255, 159, 64, 0.2)', point: 'rgba(255, 159, 64, 1)' },
                    tds: { border: 'rgba(153, 102, 255, 1)', bg: 'rgba(153, 102, 255, 0.2)', point: 'rgba(153, 102, 255, 1)' },
                    degradation: { border: 'rgba(255, 99, 132, 1)', bg: 'rgba(255, 99, 132, 0.2)', point: 'rgba(255, 99, 132, 1)' }
                };
                if (colors[currentDataset]) {
                    dataset.borderColor = colors[currentDataset].border;
                    dataset.backgroundColor = colors[currentDataset].bg;
                    dataset.pointBackgroundColor = colors[currentDataset].point;
                } else {
                    dataset.borderColor = 'rgba(0, 0, 0, 1)';
                    dataset.backgroundColor = 'rgba(0, 0, 0, 0.1)';
                    dataset.pointBackgroundColor = 'rgba(0, 0, 0, 1)';
                }
                 dashboardChart.data.labels = chartLabels;
                 dashboardChart.data.datasets[0].data = chartData[currentDataset];
                 dashboardChart.update('none');
            }
            function addChartData(dataset, value) {
                if (!isSystemRunning) return;
                tempDataForChart[dataset] = value;
            }
            function plotCollectedChartData() {
                if (!isSystemRunning) return;
                const startTime = parseInt(localStorage.getItem('startTime'), 10);
                if (!startTime) {
                    return;
                }
                const currentTime = new Date().getTime();
                const durationInSeconds = Math.floor((currentTime - startTime) / 1000);
                let newDataReceived = Object.keys(tempDataForChart).length > 0;
                let isFirstPlot = chartLabels.length === 0;
                const minutes = Math.floor(durationInSeconds / 60);
                const seconds = durationInSeconds % 60;
                const formattedDuration = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                if (newDataReceived || (isFirstPlot && durationInSeconds === 0)) {
                    chartLabels.push(formattedDuration);
                    Object.keys(chartData).forEach(datasetKey => {
                        if (tempDataForChart.hasOwnProperty(datasetKey)) {
                            const newValue = tempDataForChart[datasetKey];
                            chartData[datasetKey].push(newValue);
                            lastPlottedValue[datasetKey] = newValue;
                        } else {
                            chartData[datasetKey].push(lastPlottedValue.hasOwnProperty(datasetKey) ? lastPlottedValue[datasetKey] : null);
                        }
                    });
                    tempDataForChart = {};
                    dashboardChart.data.labels = chartLabels;
                    dashboardChart.data.datasets[0].data = chartData[currentDataset];
                    dashboardChart.update();
                    localStorage.setItem('chartData_ph', JSON.stringify(chartData.ph));
                    localStorage.setItem('chartData_turbidity', JSON.stringify(chartData.turbidity));
                    localStorage.setItem('chartData_tds', JSON.stringify(chartData.tds));
                    localStorage.setItem('chartData_degradation', JSON.stringify(chartData.degradation));
                    localStorage.setItem('chartLabels', JSON.stringify(chartLabels));
                    localStorage.setItem('lastPlottedValue', JSON.stringify(lastPlottedValue));
                }
            }
            let Co = parseFloat(localStorage.getItem('initialConcentration')) || null;
             function resetOnlineHeartbeatTimer() {
                 if (!isSystemRunning) return;
                 clearTimeout(onlineHeartbeatTimeout);
                 onlineHeartbeatTimeout = setTimeout(() => {
                     if (isSystemRunning) {
                         customAlert("Device offline or communication lost. Stopping system.", "System Alert");
                         stopSystem();
                     }
                 }, 10000);
             }
            function startDurationAndDataIntervals(startTime) {
                 clearInterval(durationInterval);
                 clearInterval(chartUpdateInterval);
                 clearInterval(dataCollectionInterval);
                 const updateDuration = () => {
                      if (!isSystemRunning) { clearInterval(durationInterval); return; }
                      const now = new Date().getTime();
                      const durationInSeconds = Math.max(0, Math.floor((now - startTime) / 1000));
                      const minutes = Math.floor(durationInSeconds / 60);
                      const seconds = durationInSeconds % 60;
                      DurasiElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                 };
                 updateDuration();
                 durationInterval = setInterval(updateDuration, 1000);
                 chartUpdateInterval = setInterval(plotCollectedChartData, 1000);
                 dataCollectionInterval = setInterval(() => {
                     if (!isSystemRunning) { clearInterval(dataCollectionInterval); return; }
                     const currentTimeStr = new Date().toLocaleTimeString();
                     const effectiveStartTime = parseInt(localStorage.getItem('startTime'), 10);
                     let durationText = "00:00";
                     if (effectiveStartTime) {
                         const now = new Date().getTime();
                         const durationInSeconds = Math.max(0, Math.floor((now - effectiveStartTime) / 1000));
                         const minutes = Math.floor(durationInSeconds / 60);
                         const seconds = durationInSeconds % 60;
                         durationText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                     }
                     const phVal = parseFloat(phElement.textContent) || 0;
                     const turbidityVal = parseFloat(turbidityElement.textContent) || 0;
                     const tdsVal = parseFloat(tdsElement.textContent) || 0;
                     const degradationTextContent = degradationElement.textContent || "0";
                     let degradationVal = 0;
                      if (degradationTextContent !== "Waiting Co..." && degradationTextContent !== "Div by Zero") {
                         degradationVal = parseFloat(degradationTextContent) || 0;
                      }
                     collectData(currentTimeStr, durationText, turbidityVal.toFixed(2), phVal.toFixed(2), tdsVal.toFixed(2), degradationVal.toFixed(2));
                     if (document.getElementById('data-monitoring')?.classList.contains('active')) {
                         updateTable();
                     }
                 }, 1000);
            }
            function startSystem() {
                if (!isSystemRunning) {
                    isSystemRunning = true;
                    localStorage.setItem('systemStatus', 'statusElement');
                    sendSystemStatus('running');
                    const startTime = new Date().getTime();
                    localStorage.setItem('startTime', startTime);
                    localStorage.removeItem('elapsedTime');
                    Co = null;
                    localStorage.removeItem('initialConcentration');
                    Object.keys(chartData).forEach(key => { chartData[key] = []; });
                    chartLabels.length = 0;
                    lastPlottedValue = {};
                    tempDataForChart = {};
                    localStorage.removeItem('chartData_ph');
                    localStorage.removeItem('chartData_turbidity');
                    localStorage.removeItem('chartData_tds');
                    localStorage.removeItem('chartData_degradation');
                    localStorage.removeItem('chartLabels');
                    localStorage.removeItem('lastPlottedValue');
                    dashboardChart.data.labels = chartLabels;
                    dashboardChart.data.datasets[0].data = chartData[currentDataset] || [];
                    dashboardChart.update('none');
                    resetTable();
                    DurasiElement.textContent = "00:00";
                    startDurationAndDataIntervals(startTime);
                    resetOnlineHeartbeatTimer();
                } else {
                }
            }
            function resumeSystem() {
                 isSystemRunning = true;
                 localStorage.setItem('systemStatus', 'running');
                 sendSystemStatus('running');
                 const now = new Date().getTime();
                 const elapsedTimeSeconds = parseInt(localStorage.getItem('elapsedTime') || '0', 10);
                 const elapsedTimeMs = elapsedTimeSeconds * 1000;
                 const effectiveStartTime = now - elapsedTimeMs;
                 localStorage.setItem('startTime', effectiveStartTime);
                 localStorage.removeItem('elapsedTime');
                 const storedCo = localStorage.getItem('initialConcentration');
                  if (storedCo) {
                       Co = parseFloat(storedCo);
                  } else {
                       Co = null;
                  }
                  loadChartDataFromStorage();
                  statusElement.textContent = localStorage.getItem('statusValue') || "N/A";
                  statusElement.style.color = localStorage.getItem('statusColor') || "black";
                  temporaryData = JSON.parse(localStorage.getItem('temporaryData')) || [];
                  updateDownloadTableDisplay();
                  updateChart(currentDataset);
                 startDurationAndDataIntervals(effectiveStartTime);
                 resetOnlineHeartbeatTimer();
                 for (const [topic, message] of Object.entries(savedConfig)) {
                     if(topic.startsWith('iot/setpoint/') || topic.startsWith('iot/light')) {
                         socket.emit("publish", { topic, message });
                     }
                 }
             }
            function stopSystem() {
                clearTimeout(onlineHeartbeatTimeout);
                onlineHeartbeatTimeout = null;
                if (isSystemRunning) {
                    isSystemRunning = false;
                    localStorage.setItem('systemStatus', 'stopped');
                    sendSystemStatus('stopped');
                    localStorage.setItem('phValue', phElement.textContent);
                    localStorage.setItem('turbidityValue', turbidityElement.textContent);
                    localStorage.setItem('tdsValue', tdsElement.textContent);
                    localStorage.setItem('degradationValue', degradationElement.textContent);
                    localStorage.setItem('statusValue', statusElement.textContent);
                    localStorage.setItem('statusColor', statusElement.style.color);
                    if(Co !== null){
                         localStorage.setItem('initialConcentration', Co.toString());
                    }
                    const startTime = parseInt(localStorage.getItem('startTime'), 10);
                    if (startTime) {
                        const stopTime = new Date().getTime();
                        const elapsedTime = Math.floor((stopTime - startTime) / 1000);
                        localStorage.setItem('elapsedTime', elapsedTime);
                        const minutes = Math.floor(elapsedTime / 60);
                        const seconds = elapsedTime % 60;
                        DurasiElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    }
                    clearInterval(durationInterval);
                    durationInterval = null;
                    clearInterval(chartUpdateInterval);
                    chartUpdateInterval = null;
                    clearInterval(dataCollectionInterval);
                    dataCollectionInterval = null;
                    plotCollectedChartData();
                    localStorage.setItem('chartData_ph', JSON.stringify(chartData.ph));
                    localStorage.setItem('chartData_turbidity', JSON.stringify(chartData.turbidity));
                    localStorage.setItem('chartData_tds', JSON.stringify(chartData.tds));
                    localStorage.setItem('chartData_degradation', JSON.stringify(chartData.degradation));
                    localStorage.setItem('chartLabels', JSON.stringify(chartLabels));
                    localStorage.setItem('lastPlottedValue', JSON.stringify(lastPlottedValue));
                    localStorage.setItem('temporaryData', JSON.stringify(temporaryData));
                } else {
                }
            }
            function resetSystem(triggeredByMQTTOrLogout = false) {
                clearTimeout(onlineHeartbeatTimeout);
                onlineHeartbeatTimeout = null;
                if (isSystemRunning) {
                    stopSystem();
                }
                isSystemRunning = false;
                localStorage.setItem('systemStatus', 'reset');
                if (!triggeredByMQTTOrLogout) {
                    sendSystemStatus('reset');
                }
                localStorage.removeItem('startTime');
                localStorage.removeItem('elapsedTime');
                localStorage.removeItem('chartData_ph');
                localStorage.removeItem('chartData_turbidity');
                localStorage.removeItem('chartData_tds');
                localStorage.removeItem('chartData_degradation');
                localStorage.removeItem('chartLabels');
                localStorage.removeItem('initialConcentration');
                localStorage.removeItem('lastPlottedValue');
                localStorage.removeItem('phValue');
                localStorage.removeItem('turbidityValue');
                localStorage.removeItem('tdsValue');
                localStorage.removeItem('degradationValue');
                localStorage.removeItem('statusValue');
                localStorage.removeItem('statusColor');
                localStorage.removeItem('savedControlConfig');
                localStorage.removeItem('temporaryData');
                Co = null;
                DurasiElement.textContent = "N/A";
                phElement.textContent = "N/A";
                turbidityElement.textContent = "N/A";
                tdsElement.textContent = "N/A";
                degradationElement.textContent = "N/A";
                statusElement.textContent = "N/A";
                statusElement.style.color = "black";
                chartLabels.length = 0;
                chartData.ph.length = 0;
                chartData.turbidity.length = 0;
                chartData.tds.length = 0;
                chartData.degradation.length = 0;
                tempDataForChart = {};
                lastPlottedValue = {};
                dashboardChart.data.labels = chartLabels;
                dashboardChart.data.datasets[0].data = chartData[currentDataset] || [];
                dashboardChart.update('none');
                resetControllingUI();
                resetTable();
                clearInterval(durationInterval); durationInterval = null;
                clearInterval(chartUpdateInterval); chartUpdateInterval = null;
                clearInterval(dataCollectionInterval); dataCollectionInterval = null;
                if (!triggeredByMQTTOrLogout) {
                    socket.emit("publish", { topic: "iot/reset", message: "1" });
                    socket.emit("publish", { topic: "iot/control", message: "0" });
                    lightCheckboxes.forEach(checkbox => {
                        if (checkbox.checked) {
                            const topic = checkbox.getAttribute('data-topic');
                            socket.emit("publish", { topic: topic, message: '0' });
                        }
                        checkbox.checked = false;
                    });
                } else {
                    lightCheckboxes.forEach(checkbox => {
                        checkbox.checked = false;
                    });
                }
            }
            let savedConfig = {};
            const lightCheckboxes = document.querySelectorAll(".checkbox[data-topic^='iot/light']");
            const setpointInputs = {
                minPH: document.getElementById("minPH"),
                maxPH: document.getElementById("maxPH"),
                maxTDS: document.getElementById("maxTDS"),
                maxPPM: document.getElementById("maxPPM"),
                Time: document.getElementById("Time")
            };
            const saveButton = document.getElementById("saveButton");
            const resetButton = document.getElementById("resetButton");
            const startButton = document.getElementById("startButton");
            const stopButton = document.getElementById("stopButton");
            const continueButton = document.getElementById("continueButton");
            const setpointTopics = {
                minPH: "iot/setpoint/ph_min",
                maxPH: "iot/setpoint/ph_max",
                maxPPM: "iot/setpoint/turbidity_max",
                maxTDS: "iot/setpoint/tds_max",
                Time: "iot/setpoint/duration_minutes"
            };
            function loadSavedConfig() {
                const storedConfig = localStorage.getItem('savedControlConfig');
                if (storedConfig) {
                    try {
                        savedConfig = JSON.parse(storedConfig);
                    } catch (e) {
                        savedConfig = {};
                    }
                } else {
                    savedConfig = {};
                }
            }
            function updateUIFromSavedConfig() {
                Object.keys(setpointInputs).forEach(key => {
                    const inputElement = setpointInputs[key];
                    const topic = setpointTopics[key];
                    if (inputElement && savedConfig.hasOwnProperty(topic)) {
                        inputElement.value = savedConfig[topic];
                    } else if (inputElement) {
                        const defaults = { minPH: '6', maxPH: '7', maxPPM: '10', maxTDS: '20', Time: '180' };
                        inputElement.value = defaults[key] || '';
                    }
                });
                lightCheckboxes.forEach(checkbox => {
                    const topic = checkbox.getAttribute("data-topic");
                    if (savedConfig.hasOwnProperty(topic)) {
                        checkbox.checked = savedConfig[topic] === '1';
                    } else {
                        checkbox.checked = false;
                    }
                });
            }
            saveButton.addEventListener("click", () => {
                customConfirm("Save current settings as the active configuration? This will overwrite previous saved settings.", "Save Configuration")
                    .then(confirmed => {
                        if (confirmed) {
                            savedConfig = {};
                            Object.keys(setpointInputs).forEach(key => {
                                const inputElement = setpointInputs[key];
                                const topic = setpointTopics[key];
                                if (inputElement && topic) {
                                    savedConfig[topic] = inputElement.value;
                                }
                            });
                            lightCheckboxes.forEach(checkbox => {
                                const topic = checkbox.getAttribute("data-topic");
                                const state = checkbox.checked ? '1' : '0';
                                savedConfig[topic] = state;
                            });
                            try {
                                localStorage.setItem('savedControlConfig', JSON.stringify(savedConfig));
                                customAlert("Configuration Saved! Press Start or Continue to apply.", "Success");
                            } catch (e) {
                                customAlert("Error saving configuration.", "Error");
                            }
                        } else {
                        }
                    });
            });
            startButton.addEventListener("click", () => {
                if (Object.keys(savedConfig).length === 0) {
                    customAlert("No configuration saved. Please set and Save Configuration before Starting.", "Configuration Needed");
                    return;
                }
                 if (isSystemRunning) {
                    customAlert("System is already running.", "Information");
                    return;
                }
                customConfirm("Start the system with the currently saved configuration?", "Start System")
                    .then(confirmed => {
                        if (confirmed) {
                            socket.emit("publish", { topic: "iot/control", message: "1" });
                            for (const [topic, message] of Object.entries(savedConfig)) {
                                socket.emit("publish", { topic, message });
                            }
                            startSystem();
                        } else {
                        }
                    });
            });
             continueButton.addEventListener("click", () => {
                if (isSystemRunning) {
                    customAlert("System is already running.", "Information");
                    return;
                }
                 const status = localStorage.getItem('systemStatus');
                 const elapsedTime = localStorage.getItem('elapsedTime');
                 if(status !== 'stopped' || !elapsedTime) {
                    customAlert("Cannot continue. The system was not previously stopped or state is missing.", "Continue Error");
                    return;
                 }
                 if (Object.keys(savedConfig).length === 0) {
                      customAlert("No saved configuration found. Cannot ensure consistent settings. Please save configuration if needed.", "Configuration Missing");
                 }
                 customConfirm("Continue the previously stopped session?", "Continue System")
                     .then(confirmed => {
                         if (confirmed) {
                             socket.emit("publish", { topic: "iot/continue", message: "1" });
                             resumeSystem();
                         } else {
                         }
                     });
             });
            stopButton.addEventListener("click", () => {
                if (!isSystemRunning) {
                    customAlert("System is not currently running.", "Information");
                    return;
                }
                customConfirm("Are you sure you want to stop the system?", "Stop System")
                    .then(confirmed => {
                        if (confirmed) {
                            socket.emit("publish", { topic: "iot/control", message: "0" });
                            lightCheckboxes.forEach(checkbox => {
                                const topic = checkbox.getAttribute('data-topic');
                                socket.emit("publish", { topic: topic, message: '0' });
                            });
                            stopSystem();
                        } else {
                        }
                    });
            });
            function resetControllingUI() {
                savedConfig = {};
                localStorage.removeItem('savedControlConfig');
                updateUIFromSavedConfig();
            }
            resetButton.addEventListener('click', function (event) {
                event.preventDefault();
                customConfirm("This will STOP the system (if running), CLEAR all current data (dashboard, chart, table), RESET controls to default, and ERASE the saved configuration. Are you sure?", "Confirm Full System Reset")
                    .then(confirmed => {
                        if (confirmed) {
                            resetSystem(false);
                        } else {
                        }
                    });
            });
            function initializeSystemState() {
                 loadSavedConfig();
                 updateUIFromSavedConfig();
                 loadChartDataFromStorage();
                 updateChart(currentDataset);
                 temporaryData = JSON.parse(localStorage.getItem('temporaryData')) || [];
                 updateDownloadTableDisplay();
                 const savedStatus = localStorage.getItem('systemStatus');
                 const savedStartTime = localStorage.getItem('startTime');
                 const savedCo = localStorage.getItem('initialConcentration');
                 const savedElapsedTime = localStorage.getItem('elapsedTime');
                 if (savedCo) {
                     Co = parseFloat(savedCo);
                 }
                 if (savedStatus === 'running' && savedStartTime) {
                    const startTime = parseInt(savedStartTime, 10);
                    isSystemRunning = true;
                    statusElement.textContent = localStorage.getItem('statusValue') || 'Running';
                    statusElement.style.color = localStorage.getItem('statusColor') || 'blue';
                    phElement.textContent = localStorage.getItem('phValue') || "N/A";
                    turbidityElement.textContent = localStorage.getItem('turbidityValue') || "N/A";
                    tdsElement.textContent = localStorage.getItem('tdsValue') || "N/A";
                    degradationElement.textContent = localStorage.getItem('degradationValue') || "N/A";
                    startDurationAndDataIntervals(startTime);
                    resetOnlineHeartbeatTimer();
                } else if (savedStatus === 'stopped') {
                    isSystemRunning = false;
                    phElement.textContent = localStorage.getItem('phValue') || "N/A";
                    turbidityElement.textContent = localStorage.getItem('turbidityValue') || "N/A";
                    tdsElement.textContent = localStorage.getItem('tdsValue') || "N/A";
                    degradationElement.textContent = localStorage.getItem('degradationValue') || "N/A";
                    statusElement.textContent = localStorage.getItem('statusValue') || "N/A";
                    statusElement.style.color = localStorage.getItem('statusColor') || "black";
                    if (savedElapsedTime) {
                        const elapsedTime = parseInt(savedElapsedTime, 10);
                        const minutes = Math.floor(elapsedTime / 60);
                        const seconds = elapsedTime % 60;
                        DurasiElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        DurasiElement.textContent = "N/A";
                    }
                } else {
                    isSystemRunning = false;
                    DurasiElement.textContent = "N/A";
                    phElement.textContent = "N/A";
                    turbidityElement.textContent = "N/A";
                    tdsElement.textContent = "N/A";
                    degradationElement.textContent = "N/A";
                    statusElement.textContent = "N/A";
                    statusElement.style.color = "black";
                    clearInterval(durationInterval); durationInterval = null;
                    clearInterval(chartUpdateInterval); chartUpdateInterval = null;
                    clearInterval(dataCollectionInterval); dataCollectionInterval = null;
                }
             }
            window.addEventListener('load', () => {
                initializeSystemState();
             });
            socket.on('mqttMessage', (data) => {
                const { topic, message } = data;
                const setpointKey = Object.keys(setpointTopics).find(key => setpointTopics[key] === topic);
                if (setpointKey && setpointInputs[setpointKey]) {
                    setpointInputs[setpointKey].value = message;
                    savedConfig[topic] = message;
                    localStorage.setItem('savedControlConfig', JSON.stringify(savedConfig));
                }
                else if (topic.startsWith('iot/light')) {
                    const lightCheckbox = document.querySelector(`.checkbox[data-topic='${topic}']`);
                    if (lightCheckbox) {
                        const targetState = message === '1';
                        if (lightCheckbox.checked !== targetState) {
                            lightCheckbox.checked = targetState;
                        }
                        savedConfig[topic] = message;
                        localStorage.setItem('savedControlConfig', JSON.stringify(savedConfig));
                    }
                }
                 else if (topic === 'iot/continue') {
                     if (message === '1' && !isSystemRunning && localStorage.getItem('systemStatus') === 'stopped') {
                        resumeSystem();
                     }
                 }
                else if (topic === 'iot/control') {
                    if (message === '1' && !isSystemRunning) {
                         if(localStorage.getItem('systemStatus') !== 'reset') {
                              customAlert("System externally started, clearing existing non-reset state and beginning new session.", "External Start");
                                resetSystem(true);
                         }
                        startSystem();
                    } else if (message === '0' && isSystemRunning) {
                        stopSystem();
                    }
                    else if (message === '1' && isSystemRunning) {
                    }
                    else if (message === '0' && !isSystemRunning) {
                         if(localStorage.getItem('systemStatus') === 'running'){
                              localStorage.setItem('systemStatus', 'stopped');
                         }
                    }
                }
                else if (topic === 'iot/reset') {
                    if (message === '1') {
                         if(!isSystemRunning && localStorage.getItem('systemStatus') === 'reset') {
                         } else {
                            resetSystem(true);
                         }
                    }
                }
                else if (topic === 'iot/online') {
                    if (message === '1' && isSystemRunning) {
                        resetOnlineHeartbeatTimer();
                    }
                }
                else if (isSystemRunning) {
                    const value = parseFloat(message);
                    if (isNaN(value)) {
                        return;
                    }
                    let dataUpdated = false;
                    if (topic === 'iot/ph') {
                        phElement.textContent = value.toFixed(2);
                        addChartData('ph', value);
                         localStorage.setItem('phValue', value.toFixed(2));
                        dataUpdated = true;
                    } else if (topic === 'iot/turbidity') {
                        turbidityElement.textContent = value.toFixed(2);
                        addChartData('turbidity', value);
                         localStorage.setItem('turbidityValue', value.toFixed(2));
                        dataUpdated = true;
                    } else if (topic === 'iot/tds') {
                        tdsElement.textContent = value.toFixed(2);
                        addChartData('tds', value);
                         localStorage.setItem('tdsValue', value.toFixed(2));
                        dataUpdated = true;
                        if (Co === null && value > 0) {
                            Co = value;
                            localStorage.setItem('initialConcentration', Co.toString());
                            const degradation = 0;
                            degradationElement.textContent = degradation.toFixed(2);
                            addChartData('degradation', degradation);
                            lastPlottedValue.degradation = degradation;
                             tempDataForChart.degradation = degradation;
                             localStorage.setItem('degradationValue', degradation.toFixed(2));
                        } else if (Co !== null && Co > 0) {
                            const degradation = Math.max(0, ((Co - value) / Co) * 100);
                            degradationElement.textContent = degradation.toFixed(2);
                            addChartData('degradation', degradation);
                            localStorage.setItem('degradationValue', degradation.toFixed(2));
                        } else if (Co === 0) {
                            degradationElement.textContent = "Div by Zero";
                            addChartData('degradation', null);
                            localStorage.setItem('degradationValue', "Div by Zero");
                        } else {
                            degradationElement.textContent = "Waiting Co...";
                            addChartData('degradation', null);
                             localStorage.setItem('degradationValue', "Waiting Co...");
                        }
                    }
                    if (dataUpdated) {
                        const currentPH = parseFloat(phElement.textContent);
                        const currentTurbidity = parseFloat(turbidityElement.textContent);
                        const currentTDS = parseFloat(tdsElement.textContent);
                        if (!isNaN(currentPH) && !isNaN(currentTurbidity) && !isNaN(currentTDS)) {
                            const phMinOk = 6.0;
                            const phMaxOk = 9.0;
                            const turbidityMaxOk = 5.0;
                            const tdsMaxOk = 500;
                            if (currentPH >= phMinOk && currentPH <= phMaxOk &&
                                currentTurbidity < turbidityMaxOk &&
                                currentTDS < tdsMaxOk)
                            {
                                statusElement.textContent = 'Safe';
                                statusElement.style.color = 'green';
                            } else {
                                statusElement.textContent = 'Not Safe';
                                statusElement.style.color = 'red';
                            }
                            localStorage.setItem('statusValue', statusElement.textContent);
                            localStorage.setItem('statusColor', statusElement.style.color);
                        } else {
                             if(localStorage.getItem('systemStatus') !== 'running') {
                                 statusElement.textContent = 'N/A';
                                 statusElement.style.color = 'black';
                                  localStorage.setItem('statusValue', 'N/A');
                                  localStorage.setItem('statusColor', 'black');
                             }
                        }
                    }
                } else {
                    const value = parseFloat(message);
                    if (isNaN(value)) {
                        return;
                    }
                     if(localStorage.getItem('systemStatus') !== 'stopped' && localStorage.getItem('systemStatus') !== 'running') {
                        if (topic === 'iot/ph') phElement.textContent = value.toFixed(2);
                        else if (topic === 'iot/turbidity') turbidityElement.textContent = value.toFixed(2);
                        else if (topic === 'iot/tds') tdsElement.textContent = value.toFixed(2);
                     }
                }
            });
            function sendDataToServer(data) {
                const userEmail = localStorage.getItem('userEmail');
                if (!userEmail) {
                    return;
                }
                const dataToSend = { ...data, userEmail: userEmail };
                fetch('/save-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(dataToSend)
                })
                .then(response => {
                    if (!response.ok) {
                        return response.text().then(text => {
                            throw new Error(`Network response was not ok: ${response.status} ${response.statusText} - ${text}`);
                        });
                    }
                     return response.text();
                })
                 .then(text => {
                     try {
                         const responseData = JSON.parse(text);
                     } catch (e) {
                      }
                 })
                .catch(error => {
                });
            }
            function sendSystemStatus(status) {
                const userEmail = localStorage.getItem('userEmail');
                if(userEmail) {
                    sendDataToServer({ systemStatus: status });
                } else {
                }
            }
             let temporaryData = JSON.parse(localStorage.getItem('temporaryData')) || [];
            function collectData(time, duration, turbidity, ph, tds, degradation) {
                 if (!isSystemRunning) return;
                 const dataPoint = { time, duration, turbidity, ph, tds, degradation };
                 temporaryData.push(dataPoint);
                  try {
                        localStorage.setItem('temporaryData', JSON.stringify(temporaryData));
                  } catch(e) {
                        temporaryData.shift();
                         localStorage.setItem('temporaryData', JSON.stringify(temporaryData));
                  }
                  if (document.getElementById('download')?.classList.contains('active') && dataTableBodyDownload && dataTableBodyDownload.style.display !== 'none') {
                      addTableRow(dataPoint);
                  }
            }
            function addTableRow(dataItem) {
                if (!dataTableBodyDownload || dataTableBodyDownload.style.display === 'none') return;
                 const row = document.createElement('tr');
                     row.innerHTML = `
                        <td>${dataItem.time}</td>
                        <td>${dataItem.duration}</td>
                        <td>${dataItem.turbidity}</td>
                        <td>${dataItem.ph}</td>
                        <td>${dataItem.tds}</td>
                        <td>${dataItem.degradation}</td>
                    `;
                if (dataTableBodyDownload.firstChild) {
                    dataTableBodyDownload.insertBefore(row, dataTableBodyDownload.firstChild);
                } else {
                    dataTableBodyDownload.appendChild(row);
                }
                 const MAX_DISPLAY_ROWS = 100;
                  while(dataTableBodyDownload.rows.length > MAX_DISPLAY_ROWS) {
                    dataTableBodyDownload.deleteRow(dataTableBodyDownload.rows.length - 1);
                  }
            }
            function resetTable() {
                 temporaryData = [];
                 localStorage.removeItem('temporaryData');
                 if (dataTableBodyDownload) {
                    dataTableBodyDownload.innerHTML = '';
                     dataTableBodyDownload.style.display = 'none';
                 }
             }
            document.getElementById('downloadCsvButton')?.addEventListener('click', () => {
                 if (temporaryData.length === 0) {
                     customAlert("No data has been collected to download.", "Download Error");
                     return;
                 }
                 customConfirm(`Download ${temporaryData.length} data rows as CSV?`, "Confirm Download")
                     .then(confirmed => {
                         if(confirmed) {
                             let csvContent = "data:text/csv;charset=utf-8,";
                             csvContent += "Time,Time Duration,Turbidity (NTU),pH,TDS (ppm),Degradation (%)\r\n";
                             temporaryData.forEach(row => {
                                 const csvRow = [
                                     `"${row.time}"`,
                                     `"${row.duration}"`,
                                     row.turbidity,
                                     row.ph,
                                     row.tds,
                                     row.degradation
                                 ].join(",");
                                 csvContent += csvRow + "\r\n";
                             });
                             const encodedUri = encodeURI(csvContent);
                             const link = document.createElement("a");
                             link.setAttribute("href", encodedUri);
                             const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                             link.setAttribute("download", `photodegradation_data_${timestamp}.csv`);
                             document.body.appendChild(link);
                             link.click();
                             document.body.removeChild(link);
                         } else {
                         }
                     });
             });
            function activateContent(targetId) {
                const contents = document.querySelectorAll('.content');
                contents.forEach(content => content.classList.remove('active'));
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.classList.add('active');
                    const dataTableContainer = document.getElementById('data-table-container');
                    document.querySelectorAll('.sidebar-links a').forEach(link => {
                        link.classList.remove('active-link');
                        if (link.getAttribute('data-target') === targetId) {
                            link.classList.add('active-link');
                        }
                    });
                    if (targetId === 'monitoring') {
                          startMonitoringUpdates();
                    } else {
                          stopMonitoringUpdates();
                    }
                      if (targetId === 'download') {
                         updateDownloadTableDisplay();
                          if (dataTableBodyDownload) dataTableBodyDownload.style.display = 'table-row-group';
                     } else if (dataTableBodyDownload) {
                          dataTableBodyDownload.style.display = 'none';
                     }
                } else {
                }
            }
            document.querySelectorAll('.sidebar-links a[data-target]').forEach(item => {
                item.addEventListener('click', function(event) {
                    event.preventDefault();
                    const targetId = this.getAttribute('data-target');
                    activateContent(targetId);
                });
            });
            document.getElementById('chartSelector').addEventListener('change', function() {
                updateChart(this.value);
            });
        </script>
        <div id="monitoring" class="content">
            <h1>Monitoring</h1>
            <div class="chart-grid">
                <div class="chart-monitoring">
                    <canvas id="phChart"></canvas>
                </div>
                <div class="chart-monitoring">
                    <canvas id="turbidityChart"></canvas>
                </div>
                <div class="chart-monitoring">
                    <canvas id="tdsChart"></canvas>
                </div>
                <div class="chart-monitoring">
                    <canvas id="degradationChart"></canvas>
                </div>
            </div>
            <script>
                const charts = [{
                    id: 'phChart',
                    label: 'pH Over Time',
                    dataset: 'ph',
                    color: 'rgba(75, 192, 192, 1)'
                },
                {
                    id: 'turbidityChart',
                    label: 'Turbidity Over Time',
                    dataset: 'turbidity',
                    color: 'rgba(255, 159, 64, 1)'
                },
                {
                    id: 'tdsChart',
                    label: 'TDS Over Time',
                    dataset: 'tds',
                    color: 'rgba(153, 102, 255, 1)'
                },
                {
                    id: 'degradationChart',
                    label: 'Degradation Over Time',
                    dataset: 'degradation',
                    color: 'rgba(255, 99, 132, 1)'
                }
                ];
                const monitoringCharts = {};
                charts.forEach(chart => {
                    const ctx = document.getElementById(chart.id)?.getContext('2d');
                    if (ctx) {
                        monitoringCharts[chart.dataset] = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: chartLabels,
                                datasets: [{
                                    label: chart.label,
                                    data: chartData[chart.dataset] || [],
                                    backgroundColor: chart.color.replace('1)', '0.2)'),
                                    borderColor: chart.color,
                                    borderWidth: 2,
                                    tension: 0.4,
                                    pointRadius: 0,
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                animation: false,
                                responsiveAnimationDuration: 0,
                                scales: {
                                    x: {
                                        title: {
                                            display: true,
                                            text: 'Time'
                                        }
                                    },
                                    y: {
                                        title: {
                                            display: true,
                                            text: 'Value'
                                        }
                                    }
                                },
                                elements: {
                                    line: {
                                        tension: 0.2
                                    },
                                    point: {
                                        radius: 3
                                    }
                                }
                            }
                        });
                    } else {
                    }
                });
                function updateMonitoringCharts() {
                    if (!document.getElementById('monitoring')?.classList.contains('active')) {
                        return;
                    }
                    charts.forEach(chart => {
                        const dataset = chart.dataset;
                        const chartInstance = monitoringCharts[dataset];
                        if (chartInstance) {
                            chartInstance.data.labels = chartLabels;
                            chartInstance.data.datasets[0].data = chartData[dataset];
                            chartInstance.update('none');
                        }
                    });
                }
                let monitoringUpdateInterval = null;
                function startMonitoringUpdates() {
                    if (!monitoringUpdateInterval) {
                        updateMonitoringCharts();
                        monitoringUpdateInterval = setInterval(updateMonitoringCharts, 1000);
                    }
                }
                function stopMonitoringUpdates() {
                    clearInterval(monitoringUpdateInterval);
                    monitoringUpdateInterval = null;
                }
            </script>
        </div>
        <div id="download" class="content">
             <h1>Download</h1>
              <div class="table-wrapper">
                <table class="excel-style-table">
                    <thead>
                        <tr>
                            <th>Time</th>
                            <th>Time Duration</th>
                            <th>Turbidity (NTU)</th>
                            <th>pH</th>
                            <th>TDS (ppm)</th>
                            <th>Degradation (%)</th>
                        </tr>
                    </thead>
                    <tbody id="data-table-body">
                    </tbody>
                 </table>
            </div>
            <div class="download-buttons">
                <button id="download-txt" class="btn">Download as TXT</button>
                <button id="download-excel" class="btn">Download as Excel</button>
                <button id="view-txt" class="btn">View/Hide Data</button>
                <button id="downloadCsvButton" class="btn" >Download CSV</button>
            </div>
             <script>
                const dataTableBodyDownload = document.getElementById('data-table-body');
                if (dataTableBodyDownload) {
                    dataTableBodyDownload.style.display = 'none';
                }
                function updateDownloadTableDisplay(data = temporaryData) {
                     if (!dataTableBodyDownload) return;
                     dataTableBodyDownload.innerHTML = '';
                      const reversedData = [...data].reverse();
                      reversedData.forEach(dataItem => {
                         const row = document.createElement('tr');
                         row.innerHTML = `
                            <td>${dataItem.time}</td>
                            <td>${dataItem.duration}</td>
                            <td>${dataItem.turbidity}</td>
                            <td>${dataItem.ph}</td>
                            <td>${dataItem.tds}</td>
                            <td>${dataItem.degradation}</td>
                        `;
                        dataTableBodyDownload.appendChild(row);
                    });
                }
                document.getElementById('view-txt').addEventListener('click', () => {
                     if (!dataTableBodyDownload) return;
                    if (dataTableBodyDownload.style.display === 'none') {
                        if (temporaryData.length === 0) {
                            customAlert("No data available to view.", "Info");
                             return;
                        }
                         updateDownloadTableDisplay();
                         dataTableBodyDownload.style.display = 'table-row-group';
                    } else {
                        dataTableBodyDownload.style.display = 'none';
                     }
                 });
                 document.getElementById('download-txt').addEventListener('click', () => {
                      if (temporaryData.length === 0) {
                         customAlert("No data available to download.", "Download Error");
                         return;
                      }
                      customConfirm(`Download ${temporaryData.length} data rows as TXT?`, "Confirm Download")
                      .then(confirmed => {
                          if(confirmed){
                              let txtContent = 'Time\tTime Duration\tTurbidity (NTU)\tpH\tTDS (ppm)\tDegradation (%)\n';
                              temporaryData.forEach(data => {
                                  txtContent += `${data.time}\t${data.duration}\t${data.turbidity}\t${data.ph}\t${data.tds}\t${data.degradation}\n`;
                              });
                              const blob = new Blob([txtContent], {
                                  type: 'text/plain'
                              });
                              const link = document.createElement('a');
                              link.href = URL.createObjectURL(blob);
                               const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                              link.download = `pomclear_sensor_data_${timestamp}.txt`;
                              link.click();
                              URL.revokeObjectURL(link.href);
                         }
                       });
                 });
                 document.getElementById('download-excel').addEventListener('click', () => {
                       if (temporaryData.length === 0) {
                          customAlert("No data available to download.", "Download Error");
                          return;
                       }
                      customConfirm(`Download ${temporaryData.length} data rows as Excel (XLS)?`, "Confirm Download")
                       .then(confirmed => {
                            if(confirmed) {
                                let excelContent = '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40"><head><meta charset="UTF-8"><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet><x:Name>SensorData</x:Name><x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions></x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml></head><body>';
                                excelContent += '<table border="1"><thead><tr><th>Time</th><th>Time Duration</th><th>Turbidity (NTU)</th><th>pH</th><th>TDS (ppm)</th><th>Degradation (%)</th></tr></thead><tbody>';
                                temporaryData.forEach(data => {
                                    excelContent += `<tr><td>${data.time || ''}</td><td>${data.duration || ''}</td><td>${data.turbidity || ''}</td><td>${data.ph || ''}</td><td>${data.tds || ''}</td><td>${data.degradation || ''}</td></tr>`;
                                });
                                excelContent += '</tbody></table></body></html>';
                                const blob = new Blob([excelContent], {
                                    type: 'application/vnd.ms-excel;charset=utf-8;'
                                });
                                const link = document.createElement('a');
                                link.href = URL.createObjectURL(blob);
                                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                                link.download = `pomclear_sensor_data_${timestamp}.xls`;
                                link.click();
                                URL.revokeObjectURL(link.href);
                        }
                        });
                });
            </script>
        </div>
        <div id="info" class="content">
            <section class="hero">
                <h1>PomClear</h1>
                <p class="tagline">Photocatalytic Degradation of Palm Oil Mill Secondary Effluent (POMSE) using TiO<sub>2</sub> Nanoparticles with Real-Time Monitoring.</p>
            </section>
            <section class="features">
                <h2>Kenapa Memilih PomClear?</h2>
                <div class="feature-grid">
                    <div class="feature-item">
                        <i class="fas fa-lightbulb"></i>
                        <h3>Teknologi Fotokatalitik</h3>
                        <p>Menggunakan TiO₂ dan cahaya UV untuk mendegradasi limbah secara efektif.</p>
                    </div>
                    <div class="feature-item">
                        <i class="fas fa-wifi"></i>
                        <h3>Monitoring Real-Time</h3>
                        <p>Pantau setiap proses dari mana saja melalui dashboard online.</p>
                    </div>
                    <div class="feature-item">
                        <i class="fas fa-cogs"></i>
                        <h3>Kontrol Otomatis</h3>
                        <p>Atur durasi reaksi dan kondisi eksperimen secara fleksibel dan otomatis.</p>
                    </div>
                </div>
            </section>
            <section class="how-it-works">
                <h2>Bagaimana PomClear Bekerja?</h2>
                <ol class="steps">
                    <li>POMSE ditempatkan dalam gelas beaker di dalam reaktor UV.</li>
                    <li>TiO<sub>2</sub> ditambahkan untuk memulai reaksi fotokatalitik.</li>
                    <li>Empat lampu UV mempercepat reaksi degradasi limbah.</li>
                    <li>Sensor memantau perubahan pH, TDS, dan Turbidity secara real-time.</li>
                    <li>Data ditransmisikan ke software untuk pemantauan dan kontrol jarak jauh.</li>
                </ol>
            </section>
            <section class="team-section">
                <h2>Dosen Pembimbing</h2>
                <div class="team-grid-simple">
                    <div class="team-card">
                        <img src="images/suratun.png" alt="Dr. Suratun Nafisah, S.Si., M.Sc.">
                        <h3>Dr. Suratun Nafisah, S.Si., M.Sc.</h3>
                        <p>Dosen Pembimbing 1</p>
                    </div>
                    <div class="team-card">
                        <img src="images/hadi.png" alt="Hadi Teguh Yudistira, S.T., Ph.D.">
                        <h3>Hadi Teguh Yudistira, S.T., Ph.D.</h3>
                        <p>Dosen Pembimbing 2</p>
                    </div>
                </div>
            </section>
            <section class="team-section">
                <h2>Tim Pengembang</h2>
                <div class="team-grid-simple">
                    <div class="team-card">
                        <img src="images/fauzi.png" alt="Muhamad Fauzi">
                        <h3>Muhamad Fauzi</h3>
                        <p>Subsistem Material</p>
                    </div>
                    <div class="team-card">
                        <img src="images/argya.png" alt="M. Argya Putra Laksono">
                        <h3>M. Argya Putra Laksono</h3>
                        <p>Subsistem Instrumentasi</p>
                    </div>
                    <div class="team-card">
                        <img src="images/jose.png" alt="Josevein Hutagalung">
                        <h3>Josevein Hutagalung</h3>
                        <p>Subsistem Internet of Things</p>
                    </div>
                </div>
            </section>
        </div>
        <div id="contact" class="content">
            <h1>Contact Us</h1>
            <form id="contactForm" action="https://formspree.io/f/mblolqzq" method="POST">
                <div class="contact-name">
                    <input type="text" name="Nama" placeholder="Name" required>
                </div>
                <div class="contact-email">
                    <input type="email" name="Email" placeholder="Email" required>
                </div>
                <div class="contact-subject">
                    <input type="text" name="Subject" placeholder="Subject" required>
                </div>
                <div class="contact-message">
                    <textarea name="Pesan" placeholder="Message" required></textarea>
                </div>
                <div class="action-btn">
                    <button type="submit" class="btn btn-submit">Send</button>
                </div>
            </form>
            <div id="notification" class="notification" style="display: none;"></div>
        </div>
        <script>
            const form = document.getElementById('contactForm');
            const notification = document.getElementById('notification');
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                const formData = new FormData(form);
                try {
                    const response = await fetch(form.action, {
                        method: 'POST',
                        body: formData,
                        headers: {
                            'Accept': 'application/json'
                        }
                    });
                    if (response.ok) {
                        showNotification("Your message was sent successfully! ✅", "success");
                        form.reset();
                    } else {
                        showNotification("Failed to send message. Please try again. ❌", "error");
                    }
                } catch (error) {
                    showNotification("An error occurred. Check your internet connection. ❌", "error");
                }
            });
            function showNotification(message, type) {
                notification.textContent = message;
                notification.className = `notification ${type}`;
                notification.style.display = "block";
                 setTimeout(() => { notification.style.display = "none"; }, 5000);
            }
        </script>
        <script>
            const links = document.querySelectorAll('.sidebar-links a[data-target]');
            const contents = document.querySelectorAll('.main-content .content');
            document.addEventListener('DOMContentLoaded', () => {
                const initialTarget = 'dashboard';
                 activateContent(initialTarget);
             });
        </script>
    </div>
</div>
</body>
</html>